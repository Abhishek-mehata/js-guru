# JavaScript Computed Properties & Dynamic Object Manipulation

This comprehensive guide demonstrates how to add properties to JavaScript objects dynamically using computed properties and dot/bracket notation, with complete working examples.

## üìö What You'll Learn

- Adding properties to objects after creation
- Using computed properties with square brackets `[]`
- Dynamic property access based on user input
- The difference between dot notation and bracket notation
- Real-world applications and advanced patterns

## üîß Complete Code Examples

### Example 1: Basic Property Addition

```javascript
/**
 * Adding property to object
 *
 * Computed Property - are used to add properties to an object dynamically.
 */

const obj = {
  name: "Krezis Alam",
  age: 25,
};

obj.city = "Biratnagar";
obj.state = "Koshi Province";
console.log(obj); // { name: 'Krezis Alam', age: 25, city: 'Biratnagar', state: 'Koshi Province' }
```

**What's happening:**

- We start with an object containing `name` and `age`
- Using dot notation, we add `city` and `state` properties
- The object is modified in place (objects are mutable in JavaScript)

**Output:**

```javascript
{
  name: 'Krezis Alam',
  age: 25,
  city: 'Biratnagar',
  state: 'Koshi Province'
}
```

### Example 2: Dynamic Property Access (Commented Version)

```javascript
const readLineSync = require("readline-sync");

// Asking the user what detail about the mentor they want (name, city, or age)
const key = readLineSync.question(
  "What do you want to know about the mentor (name/city/age)? "
);

// Asking the user which course they are interested in
const course = readLineSync.question(
  "What course are you interested in? (JavaScript/Python/Java) "
);

// Creating an object with both normal properties and a computed (dynamic) property
const mentor = {
  name: "Krezis Alam", // static property (fixed key)
  age: 25, // fixed
  city: "Islamabad", // fixed

  // Computed/Dynamic property:
  // The property course here is NOT fixed ‚Äî it depends on the value of `course` variable
  // For example, if course = "Python", then this becomes:
  // "Python": "Not available currently"
  // If course = "JavaScript", then this becomes:
  // "JavaScript": "Not available currently"
  [course]: "Not available currently",
};

console.log(mentor[key]); // Example: if key = "city" ‚Üí prints "Islamabad"

// Accessing the dynamically created course property
console.log(mentor[course]); // Example: if course = "Python" ‚Üí prints "Not available currently"

console.log(mentor);
```

**Note:** This version has an issue - `course` variable is not defined when the object is created.

### Example 3: Complete Working Interactive Example

```javascript
const readLineSync = require("readline-sync");
const key = readLineSync.question(
  "what do you want to know about the mentor (name/age/city/state) = "
);
const course = readLineSync.question(
  "Which course do you want to learn (HTML,CSS,JS,DSA,React) = "
);

const obj = {
  name: "Krezis Alam",
  age: 25,
  // courses:[""]
  [course]: "Courses are not available yet",
  // [course] will compute the property name dynamically based on the value of course variable
  // if course is "JS", then it will add a property "JS" to the object with value "Courses are not available yet"
};

obj.city = "Biratnagar";
obj.state = "Koshi Province";

// console.log(obj[key]) // dynamic property access
console.log(obj[course]);
console.log(obj);
// when course is for example "JS" then it will add a property "JS" to the object with value "Courses are not available yet"
// {
//   name: 'Krezis Alam',
//   age: 25,
//   JS: 'Courses are not available yet',
//   city: 'Biratnagar',
//   state: 'Koshi Province'
// }
```

## üéØ Step-by-Step Execution Flow

### User Input Scenario

Let's trace through what happens when:

- User enters **key**: `"name"`
- User enters **course**: `"JS"`

### Step 1: Object Creation

```javascript
const obj = {
  name: "Krezis Alam",
  age: 25,
  [course]: "Courses are not available yet", // This becomes: JS: "Courses are not available yet"
};
```

**Resulting object after creation:**

```javascript
{
    name: "Krezis Alam",
    age: 25,
    JS: "Courses are not available yet"
}
```

### Step 2: Adding More Properties

```javascript
obj.city = "Biratnagar";
obj.state = "Koshi Province";
```

**Object after additions:**

```javascript
{
    name: "Krezis Alam",
    age: 25,
    JS: "Courses are not available yet",
    city: "Biratnagar",
    state: "Koshi Province"
}
```

### Step 3: Accessing Properties

```javascript
console.log(obj[course]); // Outputs: "Courses are not available yet"
console.log(obj); // Outputs the complete object
```

## üîç Detailed Concept Explanations

### 1. Computed Property Syntax Deep Dive

```javascript
// Static property name
const obj1 = {
  name: "John", // Property name is literally "name"
};

// Computed property name
const propertyName = "name";
const obj2 = {
  [propertyName]: "John", // Property name is the value of propertyName variable
};

// Both objects are identical:
console.log(obj1); // { name: "John" }
console.log(obj2); // { name: "John" }
```

### . Advanced Computed Property Examples

```javascript
// Example 1: Using expressions in computed properties
const prefix = "user_";
const id = 123;
const user = {
  [prefix + id]: "John Doe", // Creates "user_123" property
  [`${prefix}email_${id}`]: "john@email.com", // Creates "user_email_123" property
};
console.log(user);
// {
//   user_123: "John Doe",
//   user_email_123: "john@email.com"
// }

// Example 2: Using function calls in computed properties
function getPropertyName() {
  return "dynamicProp";
}

const obj = {
  [getPropertyName()]: "This property name was computed!",
};
console.log(obj); // { dynamicProp: "This property name was computed!" }
xxc;
```

### 4. Real-World Interactive Example

```js
const readLineSync = require("readline-sync");

// Get user details
const userName = readLineSync.question("Enter your name: ");
const favoriteColor = readLineSync.question("Enter your favorite color: ");
const hobby = readLineSync.question("Enter your hobby: ");
const skillLevel = readLineSync.question(
  "Enter your skill level (beginner/intermediate/advanced): "
);

// Create object with dynamic keys
const userProfile = {
  name: userName, // fixed key
  [favoriteColor + "_theme"]: true, // dynamic key from favorite color
  [`${hobby}_enthusiast`]: true, // dynamic key from hobby
  [skillLevel]: {
    // dynamic key from skill level
    status: true,
    description: `User is at ${skillLevel} level`,
  },
};

// Add extra info
userProfile.createdAt = new Date().toISOString(); // timestamp
userProfile.id = Math.random().toString(36).substr(2, 9); // random ID

// Show profile
console.log("Generated User Profile:");
console.log(userProfile);

// Let user check any property
const propertyToAccess = readLineSync.question(
  "Which property would you like to access? "
);
if (userProfile.hasOwnProperty(propertyToAccess)) {
  console.log(`${propertyToAccess}:`, userProfile[propertyToAccess]);
} else {
  console.log(`Property '${propertyToAccess}' does not exist.`);
}
```

**Sample Output:**

```
Enter your name: Alice
Enter your favorite color: purple
Enter your hobby: photography
Enter your skill level: intermediate

Generated User Profile:
{
  name: 'Alice',
  purple_theme: true,
  photography_enthusiast: true,
  intermediate: {
    status: true,
    description: 'User is at intermediate level'
  },
  createdAt: '2024-01-15T10:30:45.123Z',
  id: 'k2j8h3n9x'
}

Which property would you like to access? purple_theme
purple_theme: true
```
<!-- 
## üöÄ Practical Applications & Use Cases

### 1. Form Data Processing

```javascript
function processFormData(formFields) {
  const formData = {};

  formFields.forEach((field) => {
    // Dynamic property creation based on form field names
    formData[field.name] = field.value;

    // Add validation property
    formData[field.name + "_valid"] = field.value.length > 0;

    // Add type-specific processing
    if (field.type === "email") {
      formData[field.name + "_formatted"] = field.value.toLowerCase();
    }
  });

  return formData;
}

// Usage example
const fields = [
  { name: "firstName", value: "John", type: "text" },
  { name: "email", value: "JOHN@EMAIL.COM", type: "email" },
  { name: "age", value: "25", type: "number" },
];

const processedData = processFormData(fields);
console.log(processedData);
// {
//   firstName: 'John',
//   firstName_valid: true,
//   email: 'JOHN@EMAIL.COM',
//   email_valid: true,
//   email_formatted: 'john@email.com',
//   age: '25',
//   age_valid: true
// }
```

### 2. API Response Transformation

```javascript
function transformApiResponse(apiData, mapping) {
  const transformed = {};

  Object.keys(mapping).forEach((apiKey) => {
    const newKey = mapping[apiKey];
    if (apiData.hasOwnProperty(apiKey)) {
      transformed[newKey] = apiData[apiKey];

      // Add computed properties
      if (typeof apiData[apiKey] === "string") {
        transformed[newKey + "_length"] = apiData[apiKey].length;
      }

      if (apiKey.includes("date")) {
        transformed[newKey + "_formatted"] = new Date(
          apiData[apiKey]
        ).toLocaleDateString();
      }
    }
  });

  return transformed;
}

// Usage example
const apiResponse = {
  user_name: "Alice Johnson",
  user_email: "alice@example.com",
  created_date: "2024-01-15T10:30:00Z",
  last_login: "2024-01-20T14:22:00Z",
};

const keyMapping = {
  user_name: "displayName",
  user_email: "email",
  created_date: "registrationDate",
  last_login: "lastActive",
};

const transformedData = transformApiResponse(apiResponse, keyMapping);
console.log(transformedData);
// {
//   displayName: 'Alice Johnson',
//   displayName_length: 13,
//   email: 'alice@example.com',
//   email_length: 17,
//   registrationDate: '2024-01-15T10:30:00Z',
//   registrationDate_formatted: '1/15/2024',
//   lastActive: '2024-01-20T14:22:00Z',
//   lastActive_formatted: '1/20/2024'
// }
```

### 3. Dynamic Configuration Builder

```javascript
class ConfigBuilder {
  constructor() {
    this.config = {};
  }

  addEnvironmentConfig(environment) {
    const envPrefix = environment.toUpperCase();

    this.config[`${environment}_mode`] = true;
    this.config[`${envPrefix}_API_URL`] =
      process.env[`${envPrefix}_API_URL`] || "http://localhost:3000";
    this.config[`${envPrefix}_DEBUG`] = environment === "development";

    return this;
  }

  addFeatureFlags(features) {
    features.forEach((feature) => {
      this.config[`feature_${feature}_enabled`] = true;
      this.config[`feature_${feature}_config`] = {
        enabled: true,
        timestamp: Date.now(),
      };
    });

    return this;
  }

  addCustomProperty(key, value) {
    this.config[key] = value;
    this.config[`${key}_set_at`] = new Date().toISOString();

    return this;
  }

  getConfig() {
    return { ...this.config };
  }
}

// Usage example
const config = new ConfigBuilder()
  .addEnvironmentConfig("development")
  .addFeatureFlags(["darkMode", "notifications", "analytics"])
  .addCustomProperty("maxRetries", 3)
  .getConfig();

console.log(config);
// {
//   development_mode: true,
//   DEVELOPMENT_API_URL: 'http://localhost:3000',
//   DEVELOPMENT_DEBUG: true,
//   feature_darkMode_enabled: true,
//   feature_darkMode_config: { enabled: true, timestamp: 1705312345678 },
//   feature_notifications_enabled: true,
//   feature_notifications_config: { enabled: true, timestamp: 1705312345678 },
//   feature_analytics_enabled: true,
//   feature_analytics_config: { enabled: true, timestamp: 1705312345678 },
//   maxRetries: 3,
//   maxRetries_set_at: '2024-01-15T10:30:45.678Z'
// }
```

## üí° Advanced Patterns & Best Practices

### 1. Computed Properties with Validation

```javascript
function createUser(userData) {
  const requiredFields = ["name", "email", "age"];
  const user = {};

  // Add regular properties with validation
  requiredFields.forEach((field) => {
    if (userData[field]) {
      user[field] = userData[field];
      user[`${field}_valid`] = true;
    } else {
      user[`${field}_valid`] = false;
      user[`${field}_error`] = `${field} is required`;
    }
  });

  // Add computed properties based on validation results
  const allValid = requiredFields.every((field) => user[`${field}_valid`]);
  user.isValid = allValid;
  user.validationSummary = {
    total: requiredFields.length,
    valid: requiredFields.filter((field) => user[`${field}_valid`]).length,
    errors: requiredFields
      .filter((field) => !user[`${field}_valid`])
      .map((field) => user[`${field}_error`]),
  };

  return user;
}

// Usage examples
console.log(
  "Valid user:",
  createUser({ name: "John", email: "john@email.com", age: 25 })
);
console.log("Invalid user:", createUser({ name: "Jane" }));
```

### 2. Dynamic Method Creation

```javascript
class DynamicCalculator {
  constructor() {
    this.operations = {};

    // Add basic operations dynamically
    ["add", "subtract", "multiply", "divide"].forEach((operation) => {
      this[operation] = this.createOperation(operation);
      this.operations[operation] = true;
    });
  }

  createOperation(type) {
    return (a, b) => {
      const operations = {
        add: (x, y) => x + y,
        subtract: (x, y) => x - y,
        multiply: (x, y) => x * y,
        divide: (x, y) => (y !== 0 ? x / y : "Cannot divide by zero"),
      };

      const result = operations[type](a, b);

      // Dynamically add result to history
      const historyKey = `${type}_history`;
      if (!this[historyKey]) {
        this[historyKey] = [];
      }
      this[historyKey].push({ a, b, result, timestamp: Date.now() });

      return result;
    };
  }

  getHistory(operation) {
    return this[`${operation}_history`] || [];
  }

  getAllOperations() {
    return Object.keys(this.operations);
  }
}

// Usage example
const calc = new DynamicCalculator();

console.log(calc.add(5, 3)); // 8
console.log(calc.multiply(4, 6)); // 24
console.log(calc.divide(10, 2)); // 5

console.log("Add history:", calc.getHistory("add"));
console.log("Available operations:", calc.getAllOperations());
```

## üéì Common Pitfalls & Solutions

### 1. Variable Scope Issues

```javascript
// ‚ùå Wrong: Variable not defined when object is created
const createObjectWrong = () => {
  const obj = {
    [someVariable]: "value", // ReferenceError: someVariable is not defined
  };
  const someVariable = "key";
  return obj;
};

// ‚úÖ Correct: Variable defined before use
const createObjectCorrect = () => {
  const someVariable = "key";
  const obj = {
    [someVariable]: "value", // Works correctly
  };
  return obj;
};
```

### 2. Property Name Conflicts

```javascript
// ‚ùå Potential issue: Property name conflicts
const userInput1 = "name";
const userInput2 = "name"; // Same as input1

const obj = {
  [userInput1]: "First value",
  [userInput2]: "Second value", // This overwrites the first property
};
console.log(obj); // { name: "Second value" } - First value is lost!

// ‚úÖ Solution: Add prefixes or validation
const createSafeObject = (inputs) => {
  const obj = {};
  const usedKeys = new Set();

  inputs.forEach((input, index) => {
    let key = input.key;

    // Handle duplicates
    if (usedKeys.has(key)) {
      key = `${key}_${index}`;
    }

    usedKeys.add(key);
    obj[key] = input.value;
  });

  return obj;
};

const result = createSafeObject([
  { key: "name", value: "First value" },
  { key: "name", value: "Second value" },
]);
console.log(result); // { name: "First value", name_1: "Second value" }
```

### 3. Type Conversion Issues

```javascript
// ‚ùå Potential issue: Non-string keys get converted to strings
const numericKey = 123;
const booleanKey = true;

const obj = {
  [numericKey]: "numeric value",
  [booleanKey]: "boolean value",
};

console.log(obj); // { "123": "numeric value", "true": "boolean value" }
console.log(obj[123]); // "numeric value" (works)
console.log(obj["123"]); // "numeric value" (also works)

// ‚úÖ Be explicit about key types if needed
const createTypedObject = (entries) => {
  const obj = {};
  const keyTypes = {};

  entries.forEach(({ key, value, keyType = "string" }) => {
    const stringKey = String(key);
    obj[stringKey] = value;
    keyTypes[stringKey] = keyType;
  });

  // Add metadata about original key types
  obj._keyTypes = keyTypes;

  return obj;
};
```

## üîß Testing Your Understanding

Here are some practice exercises to test your understanding:

### Exercise 1: Basic Dynamic Object Creation

```javascript
// Create an object that asks the user for their favorite programming languages
// and creates properties for each language with a proficiency level

const readLineSync = require("readline-sync");

function createSkillProfile() {
  const languages = ["JavaScript", "Python", "Java", "C++"];
  const profile = { name: "Developer Profile" };

  languages.forEach((lang) => {
    const level = readLineSync.question(`Rate your ${lang} skills (1-10): `);
    // Your code here: Add the language and level to the profile object
  });

  return profile;
}
```

### Exercise 2: Advanced Property Manipulation

```javascript
// Create a function that takes an array of objects and creates a summary object
// with computed properties based on the data

function createDataSummary(dataArray) {
  const summary = {};

  dataArray.forEach((item, index) => {
    // Your code here: Create dynamic properties based on item properties
    // Example: if item has 'category', create summary[category + '_count']
  });

  return summary;
}

// Test data
const testData = [
  { category: "electronics", price: 299, rating: 4.5 },
  { category: "books", price: 15, rating: 4.8 },
  { category: "electronics", price: 599, rating: 4.2 },
  { category: "clothing", price: 79, rating: 4.0 },
];
```

## üéØ Key Takeaways

1. **Computed Properties** (`[expression]`) allow dynamic property name creation at object definition time
2. **Bracket Notation** (`obj[key]`) enables dynamic property access using variables
3. **Dot Notation** (`obj.property`) is for static property access with known property names
4. **Property Addition** can happen after object creation using either notation
5. **Expression Evaluation** in computed properties happens once when the object is created
6. **String Conversion** automatically occurs for property names (numbers become strings)
7. **Best Practices** include variable scope awareness, duplicate key handling, and clear naming conventions

This comprehensive guide covers everything from basic concepts to advanced real-world applications of JavaScript's dynamic object capabilities! -->
