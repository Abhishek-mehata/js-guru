## Understanding Execution Context in JS

### JavaScript Engines

JavaScript engines are responsible for executing JavaScript code.
The two most important JavaScript engines are V8 (used in Chrome and Node.js) and SpiderMonkey (used in Firefox).
These engines follow a similar process to interpret and execute JavaScript:

#### How JavaScript Engines Interpret and Execute Code?

- Parsing: When we load a webpage or execute a script, the JavaScript engine first parses the source code to understand its structure. It converts the code into an Abstract Syntax Tree (AST) which is a hierarchical representation of the script.

- Compilation: Now in compilation phase, the engine translates the AST into machine-readable bytecode using JIT (Just-In-Time) compilation. JIT compilation optimizes performance by compiling frequently executed code segments at runtime.
- Execution: Finally, the bytecode or machine code is executed line by line, which produces the output or behavior as defined by the JavaScript code.

Here, the engine parses the calculateSum function, compiles it into bytecode or machine code, executes it with arguments 3 and 4, and logs 7 to the console.

```js
function calculateSum(a, b) {
  return a + b;
}

let result = calculateSum(3, 4);
console.log(result); // Output: 7
```

---

## Execution Context in JS

JS code is executed inside the execution context.
Unlike other programming languages JS executes it's code in very different way

---

```
-----------------------------------------------------------------
|  Browser                                                       |
|     ----------------------------------------------------       |
|     |  JS Engine                                       |       |
|     |                                                  |       |
|     |     ----------------------------------           |       |
|     |     |                                |           |       |
|     |     |  Environment                   |           |       |
|     |     |  or,                           |           |       |
|     |     |  Execution Context             |           |       |
|     |     |                                |           |       |
|     |     |                                |           |       |
|     |     |                                |           |       |
|     |     ----------------------------------           |       |
|     |                                                  |       |
|     |                                                  |       |
|     ----------------------------------------------------       |
|                                                                |
------------------------------------------------------------------
```
Whenever the browser encounters a JS code,it will bring the JS runtime engine( or, JS engine) into action.

Now this JS engine is responsible to execute the code

But how ?
In order execute code, JS engine creates an environment and inside it everything happens.
This environment is called execution context.

Whenever a code has to be executed, firstly memory allocation is done by the browser evnvironment.
Every variables and functions declared in the code is assigned to some memory and then the code is executed by the help of Execution context.
This whole process requires an evnvironment that is called execution context.

Execution context is an environment provided by JS engine where memory allocation and the code execution is actually done.

## Types of Execution Contexts

There are two primary types of execution contexts in JavaScript:

1. **Global Execution Context (GEC)**:

   - Created when the JavaScript engine starts executing a JavaScript file.
   - There is only one GEC per JavaScript file (often referred to as the "bundle file" in projects like React, where multiple JavaScript files are compiled into a single file by tools like Webpack).
   - The GEC manages global variables, functions, and the global `this` value.
     <!-- // There is only GEC(Global Execution Context) for a single page becoz it have only 1 JS file(known as "Bundle file" or "Bundle JS")
     // # Bundle JS -> normally in react or any project there can be many JS files. When the Code is compiled by webpack, it retuens single JS file which becomes main key file for a page.
     // Created when the JavaScript engine starts executing the code. There is only one GEC per JavaScript file. -->

2. **Functional Execution Context (FEC)**:
   - Created whenever a function is invoked.
   - Multiple FECs can exist within a single JavaScript file, corresponding to the number of function calls.
   - Each FEC manages its own variables, arguments, and `this` value specific to the function.
   <!-- // 2. FEC
   // There can be multiple FEC(Functional Execution Context) of a page becoz there can be multiples of functions in one JS code.
   // Created whenever a function is invoked. There can be multiple FECs depending on the number of function calls. -->

### Example

In a single JavaScript file, the GEC is created when the file is loaded. If the code contains function calls, a new FEC is created for each function invocation.

## Components of an Execution Context

An execution context consists of three main components:

1. **Variable Object / Arguments Object**:

   - Stores variable declarations (e.g., `var`, `let`, `const`) and function declarations.
   - In an FEC, it also includes the **arguments object**, which contains the parameters passed to the function.

2. **Environment for Scope and Scope Chain**:

   - Manages the scope of variables and functions, determining which variables are accessible.
   - Maintains the **scope chain**, a list of all enclosing scopes that the current execution context can access (used for variable lookup).

3. **this Keyword**:
   - Sets the value of the `this` keyword, which refers to the object that owns the current execution context.
   - In the GEC, `this` typically refers to the global object (e.g., `window` in browsers).
   - In an FEC, `this` depends on how the function is called (e.g., as a method, standalone, or with `call`/`apply`).

<!-- ## Components of an Execution Context

// 1. Variable Object / Arguments object
// Contains variable and function declarations.

// 2. Environment for scope and scope chain
// Manages the scope and scope chain.

// 3.'this' keyword
// Sets the value of 'this'.

// ----------------

// How Execution Context is created ?
// Creation of Execution Context
// Execution context is created in two phases:
// 1.Creation Phase
// 2.Execution Phase -->

<!-- ---

// | Creation Phase / Variable Environment Threads of execution
// | KEY:VALUE Execution Phase(executes the code line by line)
// |------------------------------------------------------------------------------------------------------------------------------
// | x:10 (var x=10) | 1. Line 1;
// | | 2. Line 2;
// | total: function(a,b) return a+b; | 3. Line 3;
// | | 4. Line 4;
// | |
// -------------------------------------------------------------------------------------------------------------------------------- -->

## How Execution Context is created

- Execution context is created in 2 phase.

## Phases of Execution Context Creation

The creation of an execution context occurs in two distinct phases:

1. **Creation Phase**:

- IN the creation phase the JS engine will go through the whole code and extract the variable declerations and the function declerations.
- Creation phase will only extract the variables declared by 'var' keyword only.

- This will assign the variables and functions into key and value pairs and these key and value pairs are also called variable environment.

- In creation phase of a execution context , the variable environment is also called 'memory component'

// Example

```js
// 1.
var x = 10;

// In creation phase this will be stored as
// key : value
// x : 10

// 2.
function total(a, b) {
  return a + b;
}

// In creation phase this will be stored as
// key : value
// total : function(a,b){
// return a+b;
// }
```

- Now if you will see we have key and value pair as an object in creation phase.

```
{
    x: undefined, // Initialized later to 10 during execution
    total: function(a, b) { return a + b; }
}
```

- we store those extracted form of objects into Variable Object (one of the parameter of Execution Context)

2. **Execution Phase**:

- Here Execution context creates something called thread of execution or also called code component.
- Here Execution Context will execue every single code line by line.
- JS basically executes onle line of code at a time. That's why JS is called single-threaded sunchronous programming language.

<!-- // DOes that mean JS is async ?
// No, Js is also async becoz JS shows asynchronous behaviour when needed. -->

### Visual Representation

```
-------------------------------------------------------------------------------------------------------------------------------
| Creation Phase / Variable Environment                      | Threads of Execution (Execution Phase)
|------------------------------------------------------------------------------------------------------------------------------
| x: undefined (var x = 10)                                  | 1. Assign x = 10
| total: function(a, b) { return a + b; }                    | 2. Execute function calls or other statements
-------------------------------------------------------------------------------------------------------------------------------
```

## Example: Understanding Execution Context in Action

Consider the following code:

```javascript
var x = 10;

function total(a, b) {
  var y = 5;
  return a + b + y;
}

let result = total(3, 4);
console.log(result); // Output: 12
```

### Creation Phase (GEC)

- The GEC is created when the script starts.
- Variable Object:
  ```
  {
      x: undefined, // Later assigned 10
      total: function(a, b) { ... },
      result: undefined // Later assigned the result of total(3, 4)
  }
  ```
- Scope chain and `this` are set (e.g., `this` points to the global object).

### Execution Phase (GEC)

- `x` is assigned `10`.
- The `total` function is invoked, creating an FEC.

### Creation Phase (FEC for `total`)

- Variable Object:
  ```
  {
      arguments: { a: 3, b: 4 },
      y: undefined // Later assigned 5
  }
  ```
- Scope chain includes the FEC and GEC (for accessing `x` if needed).
- `this` is set based on how `total` is called.

### Execution Phase (FEC)

- `y` is assigned `5`.
- The expression `a + b + y` (3 + 4 + 5) is evaluated, returning `12`.
- The FEC is destroyed after the function returns.

### Back to GEC

- `result` is assigned `12`.
- `console.log(result)` outputs `12`.


----
Execution contexts are managed in a call stack â€” GEC at the bottom, new FECs get pushed/popped as functions are called and returned.