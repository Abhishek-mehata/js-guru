# JavaScript Async/Await

---

## What is Async/Await?

**Async/Await** is syntactic sugar built on top of Promises that makes asynchronous code look and behave more like synchronous code. It was introduced in ES2017 (ES8) to solve the problem of "callback hell" and make promise chains more readable.

### Key Benefits:

- ‚úÖ Cleaner, more readable code
- ‚úÖ Easier error handling with try/catch
- ‚úÖ Better debugging experience
- ‚úÖ Avoids deeply nested callbacks

---

## The `async` Keyword

The `async` keyword transforms a regular function into an asynchronous function that **always returns a Promise**.

### How it Works:

```js
// Regular function
function regularFunction() {
  return "Hello";
}

// Async function - automatically wraps return value in a Promise
async function asyncFunction() {
  return "Hello";
}

// Both produce the same result:
regularFunction(); // Returns: "Hello"
asyncFunction(); // Returns: Promise { "Hello" }
```

### Behind the Scenes:

When you write:

```js
async function myFunction() {
  return "Hello";
}
```

JavaScript interprets it as:

```js
function myFunction() {
  return Promise.resolve("Hello");
}
```

### Example - Consuming an Async Function:

```js
async function sayHello() {
  return "Hello!";
}

// Since it returns a Promise, we use .then() to get the value
sayHello().then((value) => {
  console.log(value); // Output: Hello!
});

// Or we can await it inside another async function
async function main() {
  const greeting = await sayHello();
  console.log(greeting); // Output: Hello!
}
```

---

## The `await` Keyword

The `await` keyword **pauses** the execution of an async function until a Promise is settled (resolved or rejected), then returns the resolved value.

### ‚ö†Ô∏è Important Rules:

1. `await` can **only** be used inside `async` functions
2. `await` pauses the function, but doesn't block the entire program
3. Other code outside the async function continues to run

### Basic Syntax:

```js
async function main() {
  let value = await somePromiseFunction(); // ‚è∏Ô∏è Pauses here
  console.log(value); // ‚úÖ Continues after Promise resolves
}
```

### Visual Example - How `await` Pauses Execution:

```js
async function greet() {
  console.log("1. Starting...");

  // Create a Promise that resolves after 2 seconds
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Hello after 2 seconds"), 2000);
  });

  console.log("2. Before await");
  let result = await promise; // ‚è∏Ô∏è Pauses here for 2 seconds
  console.log("3. After await");
  console.log(result); // ‚úÖ Prints after 2 seconds
}

greet();
console.log("4. This runs immediately!"); // Doesn't wait for greet()

/* Output Timeline:
   Immediately:
   1. Starting...
   2. Before await
   4. This runs immediately!
   
   After 2 seconds:
   3. After await
   Hello after 2 seconds
*/
```

---

## Why Use Async/Await Over `.then()`?

### ‚ùå With `.then()` - "Promise Chain Hell"

```js
fetchUser()
  .then((user) => {
    return fetchPosts(user.id);
  })
  .then((posts) => {
    return fetchComments(posts[0].id);
  })
  .then((comments) => {
    console.log(comments);
  })
  .catch((error) => {
    console.error(error);
  });
```

### ‚úÖ With `async/await` - Clean and Readable

```js
async function getData() {
  try {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    console.log(comments);
  } catch (error) {
    console.error(error);
  }
}
```

---

## Error Handling with Try/Catch

Unlike Promises where you use `.catch()`, async/await uses **try/catch** blocks for error handling.

### Example - Handling Rejected Promises:

```js
// ‚ùå Without error handling - This will crash!
async function showResponse() {
  let promise = new Promise((res, rej) => rej("Promise rejected"));
  const result = await promise; // Uncaught error!
  console.log(result);
}

// ‚úÖ With try/catch - Proper error handling
async function showResponse() {
  try {
    let promise = new Promise((res, rej) => rej("Promise rejected"));
    const result = await promise; // If rejected, jumps to catch block
    console.log(result);
  } catch (error) {
    console.log("Error caught:", error); // Output: Error caught: Promise rejected
  }
}

showResponse();
```

### Why Try/Catch?

- **Synchronous-like error handling**: Handle errors the same way you would in regular JavaScript
- **Multiple awaits**: One try/catch can handle errors from multiple await statements
- **Cleaner code**: No need for `.catch()` chains

---

## Real-World Examples

### Example 1: Updating DOM After Async Operation

```js
async function myDisplay() {
  // Create a Promise that simulates fetching data
  let myPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("I Love JS");
    }, 4000);
  });

  // Wait for the Promise to resolve, then update the DOM
  document.getElementById("demo").innerHTML = await myPromise;
  // After 4 seconds, the DOM element will show "I Love JS"
}

myDisplay();
```

**What's happening:**

1. Function starts executing
2. Hits `await` and pauses for 4 seconds
3. Once Promise resolves, updates the DOM
4. Function completes

---

### Example 2: Sequential Task Execution

```js
// Simulates an API call that takes 3 seconds
async function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Done");
    }, 3000);
  });
}

async function main() {
  console.log("Doing Task 1"); // Executes immediately

  let data = await getData(); // ‚è∏Ô∏è Waits 3 seconds
  console.log(data); // Executes after 3 seconds

  console.log("Doing Task 2"); // Executes after data is received
}

main();

/* Output Timeline:
   Immediately:       Doing Task 1
   After 3 seconds:   Done
   Then immediately:  Doing Task 2
*/
```

**Key Point:** `"Doing Task 2"` won't execute until `getData()` is completely settled.

---

### Example 3: Fetching Data from an API

```js
const fetchData = async () => {
  try {
    // Method 1: Separate steps
    let fetchPromise = await fetch(
      "https://jsonplaceholder.typicode.com/todos/2"
    );
    let response = await fetchPromise; // Response object
    let data = await response.json(); // Parse JSON
    console.log(data);

    // Method 2: Combined (more common)
    let promise = await fetch("https://jsonplaceholder.typicode.com/todos/2");
    let jsonData = await promise.json(); // Converts Response to JSON
    console.log(jsonData);
  } catch (error) {
    console.log("Error fetching data:", error);
  }
};

fetchData();

/* Output:
   {
     userId: 1,
     id: 2,
     title: "quis ut nam facilis et officia qui",
     completed: false
   }
*/
```

**Breaking it down:**

1. `fetch()` returns a Promise that resolves to a Response object
2. `response.json()` returns another Promise that resolves to actual data
3. We `await` both to get the final data
4. Any network errors are caught in the `catch` block

---

### Example 4: Understanding Async Return Values

```js
async function returnSomething() {
  return "Abhishek Mehata";
}

let result = returnSomething();
console.log(result);

/* Output:
   Promise {<fulfilled>: "Abhishek Mehata"}
   
   The Promise object shows:
   [[PromiseState]]: "fulfilled"
   [[PromiseResult]]: "Abhishek Mehata"
*/

// To get the actual value:
result.then((value) => console.log(value)); // Output: Abhishek Mehata

// Or use await in another async function:
async function display() {
  const value = await returnSomething();
  console.log(value); // Output: Abhishek Mehata
}
```

---

## Best Practices

### 1. Always Use Try/Catch

```js
// ‚ùå Bad - No error handling
async function getData() {
  const data = await fetch(url);
  return data.json();
}

// ‚úÖ Good - Proper error handling
async function getData() {
  try {
    const data = await fetch(url);
    return await data.json();
  } catch (error) {
    console.error("Failed to fetch data:", error);
    return null;
  }
}
```

### 2. Avoid Sequential Awaits When Possible

```js
// ‚ùå Slow - Takes 6 seconds total (3 + 3)
async function slow() {
  const result1 = await fetchData1(); // 3 seconds
  const result2 = await fetchData2(); // 3 seconds
  return [result1, result2];
}

// ‚úÖ Fast - Takes 3 seconds (parallel execution)
async function fast() {
  const [result1, result2] = await Promise.all([
    fetchData1(), // Both start immediately
    fetchData2(),
  ]);
  return [result1, result2];
}
```

### 3. Remember: Async Functions Always Return Promises

```js
async function getValue() {
  return 42;
}

// ‚ùå Wrong
const value = getValue(); // This is a Promise, not 42

// ‚úÖ Correct
const value = await getValue(); // Now it's 42 (inside async context)
// OR
getValue().then((value) => console.log(value)); // 42
```

---

## Summary

| Feature   | Description                                     |
| --------- | ----------------------------------------------- |
| `async`   | Makes a function return a Promise automatically |
| `await`   | Pauses execution until Promise resolves         |
| Try/Catch | Handles errors from rejected Promises           |
| Use Case  | Cleaner code for asynchronous operations        |

**Remember:** Async/await doesn't create new functionality‚Äîit's just a more elegant way to work with Promises! Under the hood, it's all still Promises.

---

## üéØ Quick Reference

```js
// Basic async/await pattern
async function example() {
  try {
    const result = await someAsyncOperation();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}

// Parallel execution
async function parallel() {
  const [result1, result2] = await Promise.all([operation1(), operation2()]);
}

// Sequential execution
async function sequential() {
  const result1 = await operation1();
  const result2 = await operation2(result1);
}
```

---

---

## ü§ù Contributing

Feel free to contribute to this guide by adding more examples or improving explanations!

---

## üìÑ License

This guide is free to use for learning purposes.

---

**Made with ‚ù§Ô∏è by [Abhishek Mehata](https://github.com/Abhishek-mehata)**

Happy Learning! üöÄ
