# JavaScript Promise APIs


## Introduction

Promises in JavaScript help us handle asynchronous operations. When working with multiple promises, JavaScript provides special methods to manage them efficiently. Let's explore each one!

---

## 1. Promise.all() 🤝

### What is it?
`Promise.all()` runs multiple promises in parallel and waits for **ALL** of them to succeed. If even **one** promise fails, the entire operation fails immediately.

### Key Points:
- ✅ Resolves when **all** promises resolve
- ❌ Rejects immediately if **any** promise rejects
- 📦 Returns an array of all resolved values
- ⏱️ Waits for the slowest promise to complete

### Syntax:
```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.log(error));
```

### Example 1: All Promises Resolve Successfully
```javascript
// Creating three promises with different delays
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 1 resolved");  // Resolves after 3 seconds
    }, 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 2 resolved");  // Resolves after 2 seconds
    }, 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 3 resolved");  // Resolves after 1 second
    }, 1000);
});

// Put all promises in an array
let arrayOfPromises = [promise1, promise2, promise3];

// Use Promise.all() to wait for all of them
let promise = Promise.all(arrayOfPromises);

promise.then(results => {
    console.log(results);
    // Output (after 3 seconds - waiting for slowest promise):
    // ["Promise 1 resolved", "Promise 2 resolved", "Promise 3 resolved"]
});
```

### Example 2: One Promise Rejects
```javascript
let promise1 = new Promise((res, rej) => 
    setTimeout(() => res("Promise 1 resolved"), 3000)
);

let promise2 = new Promise((res, rej) => 
    setTimeout(() => rej("Promise 2 rejected"), 2000)  // This one fails!
);

let promise3 = new Promise((res, rej) => 
    setTimeout(() => res("Promise 3 resolved"), 1000)
);

let arrayOfPromises = [promise1, promise2, promise3];

Promise.all(arrayOfPromises)
    .then(results => console.log(results))
    .catch(error => console.log(error));

// Output (after 2 seconds):
// "Promise 2 rejected"
// ⚠️ Promise.all() stops immediately when promise2 rejects
// Even though promise3 resolves first, we only get the error
```

### Example 3: Real-World Use Case - Fetching Multiple Users from GitHub
```javascript
// Array of GitHub usernames we want to fetch
let users = ["Abhishek-mehata", "aman-mehta7", "torvalds"];

// Create an array of fetch promises
let arrayOfPromises = users.map(user => 
    fetch("https://api.github.com/users/" + user)
);

// Wait for all fetch requests to complete
Promise.all(arrayOfPromises)
    .then(responses => {
        // All requests succeeded! Now we have all user data
        responses.forEach(data => {
            console.log(data.url);  // Print each user's GitHub URL
        });
    })
    .catch(error => {
        // If any fetch fails (e.g., user not found), this runs
        console.log("Error fetching users:", error);
    });
```

### Example 4: Random Success/Failure Scenario
```javascript
// Promise 1: Has a 50% chance of success
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();  // Generate random number between 0 and 1
    
    if (a < 0.5) {
        // If less than 0.5, reject the promise
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        // If 0.5 or greater, resolve after 1 second
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);
    }
});

// Promise 2: Also has a 50% chance of success
let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);
    }
});

// Use Promise.all() - will only succeed if BOTH promises succeed
let p3 = Promise.all([prom1, prom2]);

p3.then((result) => {
    // This only runs if both prom1 AND prom2 resolve
    console.log(result);  // ["Abhishek - Promise 1", "Abhishek - Promise 2"]
})
.catch((err) => {
    // This runs if either prom1 OR prom2 rejects
    console.log(err);
});
```

### 🎯 Use Promise.all() When:
- You need **all** operations to succeed
- Results depend on **every** promise completing
- Example: Loading all resources before rendering a page

---

## 2. Promise.allSettled() 📋

### What is it?
`Promise.allSettled()` waits for **all** promises to complete (either resolve or reject), then returns the results of all of them. Unlike `Promise.all()`, it doesn't fail fast!

### Key Points:
- ✅ Always resolves (never rejects)
- 📊 Returns results for **all** promises
- 🎯 Each result has `status` ("fulfilled" or "rejected")
- ⏱️ Waits for all promises to settle

### Syntax:
```javascript
Promise.allSettled([promise1, promise2, promise3])
  .then(results => {
    results.forEach(result => {
      if (result.status === "fulfilled") {
        console.log("Success:", result.value);
      } else {
        console.log("Failed:", result.reason);
      }
    });
  });
```

### Example 1: All Promises Resolve
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 3 resolved"), 1000);
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.allSettled(arrayOfPromises)
    .then(response => {
        response.forEach(data => {
            console.log(data);
        });
    });

/* Output (after 3 seconds - waits for all):
{status: "fulfilled", value: "Promise 1 resolved"}
{status: "fulfilled", value: "Promise 2 resolved"}
{status: "fulfilled", value: "Promise 3 resolved"}
*/
```

### Example 2: Mixed Success and Failure
```javascript
// Three friends responding to a party invitation
let friend1 = Promise.resolve("Friend 1: I'm coming 🎉");
let friend2 = Promise.reject("Friend 2: I can't make it 😢");
let friend3 = Promise.resolve("Friend 3: I'm coming too 🥳");

Promise.allSettled([friend1, friend2, friend3])
    .then((results) => {
        results.forEach((result, index) => {
            if (result.status === "fulfilled") {
                // This friend is coming!
                console.log(`✅ Friend ${index + 1} said:`, result.value);
            } else {
                // This friend can't come
                console.log(`❌ Friend ${index + 1} said:`, result.reason);
            }
        });
    });

/* Output:
✅ Friend 1 said: Friend 1: I'm coming 🎉
❌ Friend 2 said: Friend 2: I can't make it 😢
✅ Friend 3 said: Friend 3: I'm coming too 🥳
*/
```

### Example 3: Random Success/Failure with allSettled
```javascript
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);
    }
});

let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);
    }
});

// allSettled will wait for both, regardless of success or failure
let p3 = Promise.allSettled([prom1, prom2]);

p3.then((results) => {
    console.log(results);
    // You'll get results for BOTH promises, showing their status
})
.catch((err) => {
    // This will never run! allSettled never rejects
    console.log(err);
});

/* Example Output (if prom1 succeeds, prom2 fails):
[
  {status: "fulfilled", value: "Abhishek - Promise 1"},
  {status: "rejected", reason: "Error: Random number was not supporting you - Promise 2"}
]
*/
```

### Example 4: Real-World Use Case - Fetching Multiple Users
```javascript
let users = ["Abhishek-mehata", "aman-mehta7", "invaliduser123"];

let arrayOfPromises = users.map(user => 
    fetch("https://api.github.com/users/" + user)
);

Promise.allSettled(arrayOfPromises)
    .then(responses => {
        responses.forEach((data, index) => {
            if (data.status === "fulfilled") {
                console.log(`✅ User ${users[index]} fetched successfully`);
            } else {
                console.log(`❌ Failed to fetch ${users[index]}`);
            }
        });
    });

// Even if one user doesn't exist, we still get results for all attempts!
```

### 🎯 Use Promise.allSettled() When:
- You want to know the outcome of **every** promise
- Some failures are acceptable
- Example: Sending multiple notifications (some might fail, but you want to know which ones)

---

## 3. Promise.race() 🏁

### What is it?
`Promise.race()` returns the result of the **first** promise that settles (either resolves or rejects). It's literally a race!

### Key Points:
- 🏃 Returns the **first** settled promise
- ⚡ Can resolve OR reject (depends on the winner)
- 🎯 Ignores all other promises after the first one settles
- ⏱️ Fastest promise wins

### Syntax:
```javascript
Promise.race([promise1, promise2, promise3])
  .then(result => console.log("First to finish:", result))
  .catch(error => console.log("First to finish (error):", error));
```

### Example 1: Fastest Resolved Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);  // Slowest
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);  // Medium
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 3 resolved"), 1000);  // Fastest!
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.race(arrayOfPromises)
    .then(response => {
        console.log(response);
        // Output (after 1 second): "Promise 3 resolved"
        // Promise 3 wins because it's the fastest!
    })
    .catch(err => {
        console.log(err);
    });
```

### Example 2: Fastest Rejected Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 rejected"), 1000);  // Fails first!
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.race(arrayOfPromises)
    .then(response => {
        console.log(response);
    })
    .catch(err => {
        console.log(err);
        // Output (after 1 second): "Promise 3 rejected"
        // Even though it's an error, promise3 settled first, so it wins
    });
```

### Example 3: Real-World - Choosing the Fastest Cab
```javascript
// Two cabs are on their way, take whichever arrives first
let cab1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Cab 1 arrived 🚕 (3 seconds)");
    }, 3000);
});

let cab2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Cab 2 arrived 🚖 (1 second)");
    }, 1000);
});

Promise.race([cab1, cab2])
    .then((winner) => {
        console.log("Took the first available cab:", winner);
        // Output: "Took the first available cab: Cab 2 arrived 🚖 (1 second)"
    })
    .catch((err) => {
        console.log("First response was an error:", err);
    });
```

### Example 4: Random Race with Success/Failure
```javascript
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);  // Takes 1 second if it resolves
    }
});

let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);  // Takes 3 seconds if it resolves
    }
});

// Race: whoever settles first (resolve or reject) wins
let p5 = Promise.race([prom1, prom2]);

p5.then((winner) => {
    console.log("Winner:", winner);
})
.catch((err) => {
    console.log("First to finish (with error):", err);
});

// If prom1 rejects immediately, it wins (even as an error)
// If prom1 resolves after 1 second, it wins
// prom2 rarely wins because it takes 3 seconds
```

### 🎯 Use Promise.race() When:
- You need the **fastest** response
- You want to implement timeouts
- Example: Loading data from multiple servers, use whoever responds first

---

## 4. Promise.any() 🎯

### What is it?
`Promise.any()` returns the result of the **first promise that resolves successfully**. Unlike `race()`, it ignores rejections and keeps waiting for a success.

### Key Points:
- ✅ Returns the **first successful** promise
- 🚫 Ignores rejections
- ❌ Only fails if **all** promises reject
- ⏱️ First success wins

### Syntax:
```javascript
Promise.any([promise1, promise2, promise3])
  .then(result => console.log("First success:", result))
  .catch(error => console.log("All failed:", error));
```

### Example 1: First Resolved Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);  // Fastest success!
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 rejected"), 1000);  // Fails first, but ignored
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.any(arrayOfPromises)
    .then(response => {
        console.log("First successful promise:", response);
        // Output (after 2 seconds): "Promise 2 resolved"
        // Promise 3 failed first, but Promise.any() ignored it
        // Promise 2 is the first to SUCCEED, so it wins!
    })
    .catch(err => {
        console.log("All promises failed:", err);
    });
```

### Example 2: All Promises Fail
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 1 failed"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 2 failed"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 failed"), 1000);
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.any(arrayOfPromises)
    .then(response => {
        console.log(response);
    })
    .catch(err => {
        console.log("All promises rejected:", err);
        // Output (after 3 seconds): AggregateError: All promises were rejected
    });
```

### 🎯 Use Promise.any() When:
- You need **at least one** success
- Failures are expected and acceptable
- Example: Trying to load a resource from multiple CDNs, use the first one that works

---

## Comparison Table 📊

| Method | Waits For | Result | Use Case |
|--------|-----------|--------|----------|
| `Promise.all()` | All to resolve | Array of all results OR first rejection | All must succeed |
| `Promise.allSettled()` | All to settle | Array of all results (success + failures) | Need all outcomes |
| `Promise.race()` | First to settle | First settled (success or failure) | Need fastest response |
| `Promise.any()` | First to resolve | First successful result | Need first success |

---

## Quick Reference Card 📝

```javascript
// Promise.all() - All must succeed
Promise.all([p1, p2, p3]).then(results => { /* all successful */ });

// Promise.allSettled() - Get all results
Promise.allSettled([p1, p2, p3]).then(results => { /* all completed */ });

// Promise.race() - First to finish (success or failure)
Promise.race([p1, p2, p3]).then(result => { /* fastest one */ });

// Promise.any() - First success
Promise.any([p1, p2, p3]).then(result => { /* first successful */ });

// Promise Chaining
promise
  .then(result => { /* use result */ })
  .then(result => { /* use result */ })
  .catch(error => { /* handle error */ });
```

---

## Summary 🎓

- **Promise.all()**: Use when you need **all** operations to succeed (all-or-nothing)
- **Promise.allSettled()**: Use when you need results from **all** operations (even failures)
- **Promise.race()**: Use when you need the **fastest** response (success or failure)
- **Promise.any()**: Use when you need the **first success** (ignoring failures)
- **Chaining**: Use when operations depend on each other (sequential)
- **Error Handling**: Always use `.catch()` to handle errors gracefully

---

## 🤝 Contributing

Feel free to contribute to this guide by adding more examples or improving explanations!

---

## 📄 License

This guide is free to use for learning purposes.

---

**Made with ❤️ by [Abhishek Mehata](https://github.com/Abhishek-mehata)**

Happy Learning! 🚀