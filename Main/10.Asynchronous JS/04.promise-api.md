# JavaScript Promise APIs


## Introduction

Promises in JavaScript help us handle asynchronous operations. When working with multiple promises, JavaScript provides special methods to manage them efficiently. Let's explore each one!

---

## 1. Promise.all() 🤝

### What is it?
`Promise.all()` runs multiple promises in parallel and waits for **ALL** of them to succeed. If even **one** promise fails, the entire operation fails immediately.

### Key Points:
- ✅ Resolves when **all** promises resolve
- ❌ Rejects immediately if **any** promise rejects
- 📦 Returns an array of all resolved values
- ⏱️ Waits for the slowest promise to complete

### Syntax:
```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.log(error));
```

### Example 1: All Promises Resolve Successfully
```javascript
// Creating three promises with different delays
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 1 resolved");  // Resolves after 3 seconds
    }, 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 2 resolved");  // Resolves after 2 seconds
    }, 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise 3 resolved");  // Resolves after 1 second
    }, 1000);
});

// Put all promises in an array
let arrayOfPromises = [promise1, promise2, promise3];

// Use Promise.all() to wait for all of them
let promise = Promise.all(arrayOfPromises);

promise.then(results => {
    console.log(results);
    // Output (after 3 seconds - waiting for slowest promise):
    // ["Promise 1 resolved", "Promise 2 resolved", "Promise 3 resolved"]
});
```

### Example 2: One Promise Rejects
```javascript
let promise1 = new Promise((res, rej) => 
    setTimeout(() => res("Promise 1 resolved"), 3000)
);

let promise2 = new Promise((res, rej) => 
    setTimeout(() => rej("Promise 2 rejected"), 2000)  // This one fails!
);

let promise3 = new Promise((res, rej) => 
    setTimeout(() => res("Promise 3 resolved"), 1000)
);

let arrayOfPromises = [promise1, promise2, promise3];

Promise.all(arrayOfPromises)
    .then(results => console.log(results))
    .catch(error => console.log(error));

// Output (after 2 seconds):
// "Promise 2 rejected"
// ⚠️ Promise.all() stops immediately when promise2 rejects
// Even though promise3 resolves first, we only get the error
```

### Example 3: Real-World Use Case - Fetching Multiple Users from GitHub
```javascript
// Array of GitHub usernames we want to fetch
let users = ["Abhishek-mehata", "aman-mehta7", "torvalds"];

// Create an array of fetch promises
let arrayOfPromises = users.map(user => 
    fetch("https://api.github.com/users/" + user)
);

// Wait for all fetch requests to complete
Promise.all(arrayOfPromises)
    .then(responses => {
        // All requests succeeded! Now we have all user data
        responses.forEach(data => {
            console.log(data.url);  // Print each user's GitHub URL
        });
    })
    .catch(error => {
        // If any fetch fails (e.g., user not found), this runs
        console.log("Error fetching users:", error);
    });
```

### Example 4: Random Success/Failure Scenario
```javascript
// Promise 1: Has a 50% chance of success
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();  // Generate random number between 0 and 1
    
    if (a < 0.5) {
        // If less than 0.5, reject the promise
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        // If 0.5 or greater, resolve after 1 second
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);
    }
});

// Promise 2: Also has a 50% chance of success
let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);
    }
});

// Use Promise.all() - will only succeed if BOTH promises succeed
let p3 = Promise.all([prom1, prom2]);

p3.then((result) => {
    // This only runs if both prom1 AND prom2 resolve
    console.log(result);  // ["Abhishek - Promise 1", "Abhishek - Promise 2"]
})
.catch((err) => {
    // This runs if either prom1 OR prom2 rejects
    console.log(err);
});
```

### 🎯 Use Promise.all() When:
- You need **all** operations to succeed
- Results depend on **every** promise completing
- Example: Loading all resources before rendering a page

---

## 2. Promise.allSettled() 📋

### What is it?
`Promise.allSettled()` waits for **all** promises to complete (either resolve or reject), then returns the results of all of them. Unlike `Promise.all()`, it doesn't fail fast!

### Key Points:
- ✅ Always resolves (never rejects)
- 📊 Returns results for **all** promises
- 🎯 Each result has `status` ("fulfilled" or "rejected")
- ⏱️ Waits for all promises to settle

### Syntax:
```javascript
Promise.allSettled([promise1, promise2, promise3])
  .then(results => {
    results.forEach(result => {
      if (result.status === "fulfilled") {
        console.log("Success:", result.value);
      } else {
        console.log("Failed:", result.reason);
      }
    });
  });
```

### Example 1: All Promises Resolve
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 3 resolved"), 1000);
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.allSettled(arrayOfPromises)
    .then(response => {
        response.forEach(data => {
            console.log(data);
        });
    });

/* Output (after 3 seconds - waits for all):
{status: "fulfilled", value: "Promise 1 resolved"}
{status: "fulfilled", value: "Promise 2 resolved"}
{status: "fulfilled", value: "Promise 3 resolved"}
*/
```

### Example 2: Mixed Success and Failure
```javascript
// Three friends responding to a party invitation
let friend1 = Promise.resolve("Friend 1: I'm coming 🎉");
let friend2 = Promise.reject("Friend 2: I can't make it 😢");
let friend3 = Promise.resolve("Friend 3: I'm coming too 🥳");

Promise.allSettled([friend1, friend2, friend3])
    .then((results) => {
        results.forEach((result, index) => {
            if (result.status === "fulfilled") {
                // This friend is coming!
                console.log(`✅ Friend ${index + 1} said:`, result.value);
            } else {
                // This friend can't come
                console.log(`❌ Friend ${index + 1} said:`, result.reason);
            }
        });
    });

/* Output:
✅ Friend 1 said: Friend 1: I'm coming 🎉
❌ Friend 2 said: Friend 2: I can't make it 😢
✅ Friend 3 said: Friend 3: I'm coming too 🥳
*/
```

### Example 3: Random Success/Failure with allSettled
```javascript
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);
    }
});

let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);
    }
});

// allSettled will wait for both, regardless of success or failure
let p3 = Promise.allSettled([prom1, prom2]);

p3.then((results) => {
    console.log(results);
    // You'll get results for BOTH promises, showing their status
})
.catch((err) => {
    // This will never run! allSettled never rejects
    console.log(err);
});

/* Example Output (if prom1 succeeds, prom2 fails):
[
  {status: "fulfilled", value: "Abhishek - Promise 1"},
  {status: "rejected", reason: "Error: Random number was not supporting you - Promise 2"}
]
*/
```

### Example 4: Real-World Use Case - Fetching Multiple Users
```javascript
let users = ["Abhishek-mehata", "aman-mehta7", "invaliduser123"];

let arrayOfPromises = users.map(user => 
    fetch("https://api.github.com/users/" + user)
);

Promise.allSettled(arrayOfPromises)
    .then(responses => {
        responses.forEach((data, index) => {
            if (data.status === "fulfilled") {
                console.log(`✅ User ${users[index]} fetched successfully`);
            } else {
                console.log(`❌ Failed to fetch ${users[index]}`);
            }
        });
    });

// Even if one user doesn't exist, we still get results for all attempts!
```

### 🎯 Use Promise.allSettled() When:
- You want to know the outcome of **every** promise
- Some failures are acceptable
- Example: Sending multiple notifications (some might fail, but you want to know which ones)

---

## 3. Promise.race() 🏁

### What is it?
`Promise.race()` returns the result of the **first** promise that settles (either resolves or rejects). It's literally a race!

### Key Points:
- 🏃 Returns the **first** settled promise
- ⚡ Can resolve OR reject (depends on the winner)
- 🎯 Ignores all other promises after the first one settles
- ⏱️ Fastest promise wins

### Syntax:
```javascript
Promise.race([promise1, promise2, promise3])
  .then(result => console.log("First to finish:", result))
  .catch(error => console.log("First to finish (error):", error));
```

### Example 1: Fastest Resolved Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);  // Slowest
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);  // Medium
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 3 resolved"), 1000);  // Fastest!
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.race(arrayOfPromises)
    .then(response => {
        console.log(response);
        // Output (after 1 second): "Promise 3 resolved"
        // Promise 3 wins because it's the fastest!
    })
    .catch(err => {
        console.log(err);
    });
```

### Example 2: Fastest Rejected Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 rejected"), 1000);  // Fails first!
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.race(arrayOfPromises)
    .then(response => {
        console.log(response);
    })
    .catch(err => {
        console.log(err);
        // Output (after 1 second): "Promise 3 rejected"
        // Even though it's an error, promise3 settled first, so it wins
    });
```

### Example 3: Real-World - Choosing the Fastest Cab
```javascript
// Two cabs are on their way, take whichever arrives first
let cab1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Cab 1 arrived 🚕 (3 seconds)");
    }, 3000);
});

let cab2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Cab 2 arrived 🚖 (1 second)");
    }, 1000);
});

Promise.race([cab1, cab2])
    .then((winner) => {
        console.log("Took the first available cab:", winner);
        // Output: "Took the first available cab: Cab 2 arrived 🚖 (1 second)"
    })
    .catch((err) => {
        console.log("First response was an error:", err);
    });
```

### Example 4: Random Race with Success/Failure
```javascript
let prom1 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 1");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 1");
            resolve("Abhishek - Promise 1");
        }, 1000);  // Takes 1 second if it resolves
    }
});

let prom2 = new Promise((resolve, reject) => {
    let a = Math.random();
    
    if (a < 0.5) {
        reject("Error: Random number was not supporting you - Promise 2");
    } else {
        setTimeout(() => {
            console.log("Yes I'm done - Promise 2");
            resolve("Abhishek - Promise 2");
        }, 3000);  // Takes 3 seconds if it resolves
    }
});

// Race: whoever settles first (resolve or reject) wins
let p5 = Promise.race([prom1, prom2]);

p5.then((winner) => {
    console.log("Winner:", winner);
})
.catch((err) => {
    console.log("First to finish (with error):", err);
});

// If prom1 rejects immediately, it wins (even as an error)
// If prom1 resolves after 1 second, it wins
// prom2 rarely wins because it takes 3 seconds
```

### 🎯 Use Promise.race() When:
- You need the **fastest** response
- You want to implement timeouts
- Example: Loading data from multiple servers, use whoever responds first

---

## 4. Promise.any() 🎯

### What is it?
`Promise.any()` returns the result of the **first promise that resolves successfully**. Unlike `race()`, it ignores rejections and keeps waiting for a success.

### Key Points:
- ✅ Returns the **first successful** promise
- 🚫 Ignores rejections
- ❌ Only fails if **all** promises reject
- ⏱️ First success wins

### Syntax:
```javascript
Promise.any([promise1, promise2, promise3])
  .then(result => console.log("First success:", result))
  .catch(error => console.log("All failed:", error));
```

### Example 1: First Resolved Promise Wins
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 1 resolved"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise 2 resolved"), 2000);  // Fastest success!
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 rejected"), 1000);  // Fails first, but ignored
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.any(arrayOfPromises)
    .then(response => {
        console.log("First successful promise:", response);
        // Output (after 2 seconds): "Promise 2 resolved"
        // Promise 3 failed first, but Promise.any() ignored it
        // Promise 2 is the first to SUCCEED, so it wins!
    })
    .catch(err => {
        console.log("All promises failed:", err);
    });
```

### Example 2: All Promises Fail
```javascript
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 1 failed"), 3000);
});

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 2 failed"), 2000);
});

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => reject("Promise 3 failed"), 1000);
});

let arrayOfPromises = [promise1, promise2, promise3];

Promise.any(arrayOfPromises)
    .then(response => {
        console.log(response);
    })
    .catch(err => {
        console.log("All promises rejected:", err);
        // Output (after 3 seconds): AggregateError: All promises were rejected
    });
```

### 🎯 Use Promise.any() When:
- You need **at least one** success
- Failures are expected and acceptable
- Example: Trying to load a resource from multiple CDNs, use the first one that works

---

## Comparison Table 📊

| Method | Waits For | Result | Use Case |
|--------|-----------|--------|----------|
| `Promise.all()` | All to resolve | Array of all results OR first rejection | All must succeed |
| `Promise.allSettled()` | All to settle | Array of all results (success + failures) | Need all outcomes |
| `Promise.race()` | First to settle | First settled (success or failure) | Need fastest response |
| `Promise.any()` | First to resolve | First successful result | Need first success |

---

## Promise Chaining ⛓️

### What is it?
Promise chaining allows you to execute asynchronous operations **in sequence**, where each operation starts after the previous one completes.

### Key Points:
- 🔗 Execute promises one after another
- 📤 Each `.then()` can return a value or another promise
- 🎯 Great for dependent operations
- ⏱️ Operations happen in order

### Example 1: Simple Sequential Tasks
```javascript
// Define a function that simulates a task with a delay
function task(message, delay) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log(message);  // Print the message
            resolve();             // Mark task as complete
        }, delay);
    });
}

// Chain multiple tasks together
task('Task 1 completed', 1000)                  // Starts immediately, completes after 1 second
    .then(() => task('Task 2 completed', 2000)) // Starts after Task 1, takes 2 seconds
    .then(() => task('Task 3 completed', 1000)); // Starts after Task 2, takes 1 second

/* Output:
(after 1 second) Task 1 completed
(after 2 more seconds) Task 2 completed
(after 1 more second) Task 3 completed
Total time: 4 seconds (1 + 2 + 1)
*/
```

### Example 2: Dependent Operations - Fetch User, Then Fetch Orders
```javascript
// Function that simulates fetching a user from database
function fetchUser(userId) {
    console.log("Fetching user...");
    // Returns a promise that resolves with user data
    return Promise.resolve({ 
        id: userId, 
        name: "Abhishek Mehata" 
    });
}

// Function that simulates fetching orders for a user
function fetchOrders(user) {
    console.log("Fetching orders for:", user.name);
    // Returns a promise with orders for this user
    return Promise.resolve([
        { orderId: 1, userId: user.id, item: "Laptop" },
        { orderId: 2, userId: user.id, item: "Mouse" }
    ]);
}

// Chain them together - each step depends on the previous one
fetchUser(101)
    .then((user) => {
        // Step 1: Got the user data
        console.log(`User Found: ${user.name} (ID: ${user.id})`);
        
        // Step 2: Now fetch orders for this user
        // IMPORTANT: Return the next promise to continue the chain
        return fetchOrders(user);
    })
    .then((orders) => {
        // Step 3: Got the orders
        console.log(`Total Orders: ${orders.length}`);
        orders.forEach(order => {
            console.log(`- Order ${order.orderId}: ${order.item}`);
        });
    })
    .catch((error) => {
        // Catches any error from the entire chain
        console.error("Something went wrong:", error);
    });

/* Output:
Fetching user...
User Found: Abhishek Mehata (ID: 101)
Fetching orders for: Abhishek Mehata
Total Orders: 2
- Order 1: Laptop
- Order 2: Mouse
*/
```

### Example 3: Real-World API Chaining
```javascript
// Fetch user, then their repos, then details of first repo
fetch('https://api.github.com/users/Abhishek-mehata')
    .then(response => response.json())  // Convert response to JSON
    .then(user => {
        console.log(`User: ${user.name}`);
        console.log(`Public Repos: ${user.public_repos}`);
        
        // Fetch this user's repositories
        return fetch(user.repos_url);
    })
    .then(response => response.json())
    .then(repos => {
        console.log(`First repo: ${repos[0].name}`);
        
        // Fetch details of the first repository
        return fetch(repos[0].url);
    })
    .then(response => response.json())
    .then(repoDetails => {
        console.log(`Stars: ${repoDetails.stargazers_count}`);
        console.log(`Forks: ${repoDetails.forks_count}`);
    })
    .catch(error => {
        console.error("Error in the chain:", error);
    });
```

---

## Error Handling in Chaining 🛡️

### How Errors Propagate in Promise Chains

When an error occurs anywhere in a promise chain, it **jumps directly to the nearest `.catch()` block**, skipping all `.then()` blocks in between.

### Example 1: Error in the Middle of Chain
```javascript
const myPromise = new Promise((resolve, reject) => {
    resolve("Step 1 complete");  // Start successfully
});

myPromise
    .then((message) => {
        console.log(message);  // Output: "Step 1 complete"
        return "Step 2 complete";
    })
    .then((message) => {
        console.log(message);  // Output: "Step 2 complete"
        
        // Simulate an error happening here
        throw new Error("Something went wrong in Step 3!");
    })
    .then((message) => {
        // ❌ THIS WILL NEVER RUN because an error occurred above
        console.log("Step 3:", message);
    })
    .then((message) => {
        // ❌ THIS WILL ALSO NEVER RUN
        console.log("Step 4:", message);
    })
    .catch((error) => {
        // ✅ Error jumps directly here, skipping all .then() above
        console.error("Caught Error:", error.message);
        // Output: "Caught Error: Something went wrong in Step 3!"
    });

/* Complete Output:
Step 1 complete
Step 2 complete
Caught Error: Something went wrong in Step 3!
*/
```

### Example 2: Multiple Catch Blocks
```javascript
function fetchData(success) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (success) {
                resolve("Data fetched successfully");
            } else {
                reject("Failed to fetch data");
            }
        }, 1000);
    });
}

fetchData(false)  // Deliberately fail
    .then(data => {
        console.log(data);
        return "Processing data...";
    })
    .catch(error => {
        // First catch: handles errors from fetchData
        console.error("Error in fetching:", error);
        // Return a value to continue the chain
        return "Using cached data instead";
    })
    .then(data => {
        // This WILL run because previous catch returned a value
        console.log(data);  // Output: "Using cached data instead"
        
        // Simulate another error
        throw new Error("Processing failed");
    })
    .catch(error => {
        // Second catch: handles the new error
        console.error("Error in processing:", error.message);
    });

/* Output:
Error in fetching: Failed to fetch data
Using cached data instead
Error in processing: Processing failed
*/
```

### Example 3: Recovering from Errors
```javascript
Promise.resolve("Start")
    .then(result => {
        console.log(result);
        throw new Error("Oops, something broke!");
    })
    .catch(error => {
        // Catch the error and recover
        console.log("Caught:", error.message);
        return "Recovered!";  // Return a value to continue normally
    })
    .then(result => {
        // Chain continues normally after recovery
        console.log("Continuing with:", result);
        return "All done";
    })
    .then(result => {
        console.log(result);
    });

/* Output:
Start
Caught: Oops, something broke!
Continuing with: Recovered!
All done
*/
```

### Best Practices for Error Handling:
1. ✅ Always add a `.catch()` at the end of promise chains
2. ✅ Handle errors at appropriate levels
3. ✅ Return values from `.catch()` to recover and continue the chain
4. ✅ Use specific error messages for debugging
5. ❌ Don't silently ignore errors

---

## Quick Reference Card 📝

```javascript
// Promise.all() - All must succeed
Promise.all([p1, p2, p3]).then(results => { /* all successful */ });

// Promise.allSettled() - Get all results
Promise.allSettled([p1, p2, p3]).then(results => { /* all completed */ });

// Promise.race() - First to finish (success or failure)
Promise.race([p1, p2, p3]).then(result => { /* fastest one */ });

// Promise.any() - First success
Promise.any([p1, p2, p3]).then(result => { /* first successful */ });

// Promise Chaining
promise
  .then(result => { /* use result */ })
  .then(result => { /* use result */ })
  .catch(error => { /* handle error */ });
```

---

## Summary 🎓

- **Promise.all()**: Use when you need **all** operations to succeed (all-or-nothing)
- **Promise.allSettled()**: Use when you need results from **all** operations (even failures)
- **Promise.race()**: Use when you need the **fastest** response (success or failure)
- **Promise.any()**: Use when you need the **first success** (ignoring failures)
- **Chaining**: Use when operations depend on each other (sequential)
- **Error Handling**: Always use `.catch()` to handle errors gracefully

---

## 🤝 Contributing

Feel free to contribute to this guide by adding more examples or improving explanations!

---

## 📄 License

This guide is free to use for learning purposes.

---

**Made with ❤️ by [Abhishek Mehata](https://github.com/Abhishek-mehata)**

Happy Learning! 🚀