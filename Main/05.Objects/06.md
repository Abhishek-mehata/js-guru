# JavaScript Object References and Copying


## üîó Object References

When you assign an object to a variable, JavaScript doesn't create a new object. Instead, it creates a **reference** (or pointer) to the same object in memory.

In short JS lets both variable to share same memory.

### Example 1: Basic Object Reference
```javascript
const person1 = {
    name: "Abhishek",
    age: 101
}

const person2 = person1; // This is a reference to the same object
// We are just assigning the person1 reference to person2
person1.name = "Rakesh"
console.log(person2)
// Output: { name: 'Rakesh', age: 101 }
```

**Explanation**: Reference to any object means if we change the original object, then the copied reference will also reflect the changes.

### Example 2: Changing Through Different Reference
```javascript
const person1 = {
    name: "Abhishek",
    age: 101
}

const person2 = person1; // This is a reference to the same object

person2.name = "Rakesh"; // Changing the name in person2 will also change it in person1
// because person2 is just a reference to the same object as person1
console.log(person2);
console.log(person1)
```

## üìã Shallow Copy vs Deep Copy

### Definitions:
- **Shallow copy**: The new object will have the same reference to the original object. If we change any property of the new or original object, then that change will be reflected in both objects because they are pointing or working on the same memory location.

- **Deep copy**: The new object will have a different reference to the original object. If we change any property of the new or original object, then that change will not be reflected in both objects because they are pointing or working on different memory locations.

Deep copy can be achieved using JSON methods or libraries like Lodash or spread operator.

## üõ†Ô∏è Methods for Copying

### 1. Object.assign() Method

```javascript
const person1 = {
    name: "Ashmita Yadav",
    age: 18
}

// Object.assign creates a new object {}(i.e in parameter)
// and copies the properties of person1 into it.
// Now person2 is a separate object with its own reference, so changes to person2 will
// not affect person1 and vice versa.
const person2 = Object.assign({}, person1); // this is a deep copy of the person1 object
// it will copy the properties of person1 and store them into an empty object {}.
// Now person2 is a separate object with its own reference.

console.log(person2)
```

### Example: Testing Object.assign()
```javascript
const person1 = {
    name: "Ashmita Yadav",
    age: 18
}

const person2 = Object.assign({}, person1);

person2.name = "Rakesh";
person1.age = 111;

console.log(person1); // { name: 'Ashmita Yadav', age: 111 }
console.log(person2); // { name: 'Rakesh', age: 18 }
// person1 remains unchanged because person2 is a deep copy of person1.
```

### 2. The Problem with Nested Objects

‚ö†Ô∏è **Important**: The above is actually still not a true deep copy! When we have nested objects, the Object.assign method creates a shallow copy. This means that if the object has nested objects, the nested objects will still reference the same memory location. So changes to the nested objects will affect both the original and the copied object.

```javascript
const person1 = {
    name: "Ashu",
    age: 18,
    address: {
        city: "Biratnagar",
        state: "Koshi"
    }
}

const person2 = Object.assign({}, person1); // Shallow copy

person2.name = "Abhi";
person2.address.city = "Kathmandu";
person2.address.state = "Bagmati"
person1.age = 111;

console.log(person1);
console.log(person2);
// Output:
// {
//   name: 'Ashu',
//   age: 111,
//   address: { city: 'Kathmandu', state: 'Bagmati' }
// }
// {
//   name: 'Abhi',
//   age: 18,
//   address: { city: 'Kathmandu', state: 'Bagmati' }
// }
```

**Why this happens**: Though person1 and person2 as objects are pointing to different memory locations, `person1.address` and `person2.address` are pointing to the same memory. So this behavior happens.

### 3. True Deep Copy using JSON Methods

```javascript
const person1 = {
    name: 'Ashu',
    age: 19,
    address: {
        city: 'Biratnagar',
        state: 'Koshi'
    }
};

const person2 = JSON.parse(JSON.stringify(person1)); // Deep copy
// JSON.stringify converts the object to a JSON string (simply a string representation)
// JSON.parse converts the JSON string back to an object

// person2 is now a deep copy of person1
// Changes to person2 will not affect person1
person2.name = "Abhi";
person2.address.city = "Kathmandu";
person2.address.state = "Bagmati";

console.log(person1)
console.log(person2)
// Output:
// {
//   name: 'Ashu',
//   age: 19,
//   address: { city: 'Biratnagar', state: 'Koshi' }
// }
// {
//   name: 'Abhi',
//   age: 19,
//   address: { city: 'Kathmandu', state: 'Bagmati' }
// }
```

### 4. Using Spread Operator

```javascript
const person1 = {
    name: 'Ashu',
    age: 101,
    address: {
        city: 'Biratnagar',
        state: 'Koshi'
    }
};

const person2 = { ...person1 }; // Shallow copy but not deep copy
person2.name = 'Abhi';
person2.address.city = 'Kathmandu';
person2.address.state = 'Bagmati';

console.log(person1)
console.log(person2)
// Output shows that nested objects are still shared!
```

## üéØ Quick Reference Table

| Method | Type | Nested Objects Safe? | Example |
|--------|------|---------------------|---------|
| `=` assignment | Reference | ‚ùå No | `const obj2 = obj1` |
| `Object.assign()` | Shallow Copy | ‚ùå No | `Object.assign({}, obj1)` |
| `{...obj}` (Spread) | Shallow Copy | ‚ùå No | `{...obj1}` |
| `JSON.parse(JSON.stringify())` | Deep Copy | ‚úÖ Yes | `JSON.parse(JSON.stringify(obj1))` |


## Key Takeaway

The main lesson from these examples is understanding the difference between:
- **References**: Same object, same memory location
- **Shallow Copy**: New object, but nested objects still shared
- **Deep Copy**: Completely independent objects at all levels